module org:protelis:convergeExperiment
import org:protelis:armonicCentralityHLL
import protelis:coord:nonselfstabilizing:accumulation
import protelis:coord:meta
import protelis:coord:spreading
import protelis:coord:accumulation
import it.unibo.hll.HarmonicCentrality.*
import it.unibo.hll.ClosenessCentrality.*
import protelis:lang:utils

// degree of a node, used as centrality measure
def degree() = foldSum(0, nbr(1))

def pageRank() = share (rank <- 1) { foldSum(0.15, 0.85 / nbr(degree()) * rank) }

def diameterBoundGossip(value, diameter, merge) {
    let local = [value, 0]
    share (field <- local) {
        let options = mux (field.get(1) <= diameter + 1) { field } else { local }
//        env.putField("options", options)
        let wanted = foldHood(local.get(0), options.get(0), merge)
//        env.put("wanted", wanted)
        let filtered = mux(options.get(0) == wanted) { options } else { [wanted, POSITIVE_INFINITY] }
//        env.putField("filtered", filtered)
        let folded = foldMin(filtered)
//        env.put("folded", folded)
        folded.set(1, folded.get(1) + 1)
    }.get(0)
}

let myId = self.getDeviceUID().getId()
let estimates = hyperANF2(1000)
let nodes = env.get("nodes")
let diameter = env.get("diameter")
let centralities = [
    ["central", if(myId == ceil(nodes/2)) { 1 } else { 0 }],
    ["extreme", myId],
    ["random", rep(c <- self.nextRandomDouble()) { c }],
    ["pageRank", pageRank()],
    ["harmonic", harmonicCentralityFromHLL(estimates)],
    ["closeness", closenessCentralityFromHLL(estimates)],
    ["degree", degree()]
]
let now = self.getCurrentTime()
let tieBreaker = rep(v <- self.nextRandomDouble()) { v }
centralities.map { descriptor ->
    let name = descriptor.get(0)
    let centrality = descriptor.get(1)
    let gossip = diameterBoundGossip([centrality, tieBreaker, myId], diameter, max)
    env.put(name + "gossip", gossip)
    let leader = myId == gossip.get(2) // myId as tie breaker
    let accumulated = C(distanceTo(leader), min, now, now)
    let valueLabel = "value-"+name
    let errorLabel = "error-"+name
    if (leader) {
        env.put(valueLabel, accumulated)
        env.put(errorLabel, now - accumulated)
    } else {
        if (env.has(valueLabel)) {
            env.remove(valueLabel)
            env.remove(errorLabel)
        } else { 0 }
    }
    [name, centrality, accumulated, now-accumulated]
}
