incarnation: protelis

variables:
  nodeCount: &nodeCount
    formula: 5
  meanNeighbors:
    formula: 10
  commRange: &commRange
    formula: 500 * Math.sqrt(meanNeighbors / Math.PI / nodeCount)
  speed: &speed
    formula: 10
  log2m: &log2m
    formula: 11
  regsize: &regsize
    formula: 5
  stepsCheck: &stepsCheck
    formula: 3 * nodeCount
  samplingRate: &samplingRate
    formula: 1/2

environment:
  type: ImageEnvironment
  parameters: [square.png]

network-model:
  type: ConnectWithinDistance
  parameters: [*commRange]

export:
  - time
  - type: NumberOfNodes
  - molecule: "org:protelis:armonicCentralityHLL"
    value-filter: onlyfinite
    aggregators: [mean]
  - molecule: "harmonicCentrality"
    value-filter: onlyfinite
    aggregators: [mean]
  - molecule: harmonicCentrality
    property: |
      // msqer
      sqrt((optionally(<value>).orElse(0) - env.get("org:protelis:armonicCentralityHLL", 0)) ^ 2)
    value-filter: onlyfinite
    aggregators: [mean, max, min]

hyperanf: &hyperanf
  - time-distribution: 1
    # Writing Protelis programs within a YAML file is a bad experience
    # (some characters need escaping, no syntax highlight, no code suggestions...)
    # We recommend using the Protelis Eclipse plugin to write your code, then
    # Loading the code as a module within Alchemist
    # In order to run this example, make sure that src/main/protelis is part of
    # your classpath (the Gradle script is already properly configured).
    program: org:protelis:armonicCentralityHLL
  - program: send

harmonicOracle: &harmonicOracle
  - type: ChemicalReaction
    actions:
      - type: ComputeHarmonicCentrality
    conditions:
      - type: NeighborhoodChanged
        parameters: [true]

move: &move
  - time-distribution:
      type: ExponentialTime
      parameters: [1]
    type: Event
    actions:
      - type: LevyWalk
        parameters: [*speed, 100, 1]

staticOracle: &staticOracle
  - time-distribution:
      type: DiracComb
      parameters: [*samplingRate]
    program: "import it.unibo.hll.HarmonicCentrality.* recomputeHarmonicCentrality()"

displacements:
#  - in:
#      type: Rectangle
#      parameters: [1, 1, 1, 498, 498]
#    programs:
#      - *hyperanf
#      - *staticOracle
#      - *move
  - in:
      type: Rectangle
      parameters: [*nodeCount, 1, 1, 498, 498]
    programs:
      - *hyperanf
      - *harmonicOracle
      - *move
    contents:
      - molecule: regsize
        concentration: *regsize
      - molecule: log2m
        concentration: *log2m

terminate:
  - type: StableForSteps
    parameters: [*stepsCheck, 3]
  - type: AfterTime
    parameters: [500000]